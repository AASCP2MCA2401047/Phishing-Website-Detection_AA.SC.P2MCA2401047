import pandas as pd
import numpy as np
import re
from urllib.parse import urlparse
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix

# --- MODULE 1: FEATURE EXTRACTION (Section 3.4 B & Appendix A) ---
def extract_features(url):
    """
    Extracts features from a URL as defined in the project scope.
    1 = Phishing/Suspicious, 0 = Legitimate
    """
    features = {}
    
    # 1. Presence of IP Address (cite: 212, 3.1)
    ip_pattern = r'(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])'
    features['having_IP'] = 1 if re.search(ip_pattern, url) else 0
    
    # 2. URL Length (cite: 212, 3.1)
    # Standard threshold: > 54 characters is often flagged as suspicious
    features['URL_Length'] = 1 if len(url) >= 54 else 0
    
    # 3. Presence of "@" Symbol (cite: 3.1)
    features['Have_At'] = 1 if "@" in url else 0
    
    # 4. Redirection "//" (cite: 3.1)
    features['Redirection'] = 1 if url.rfind('//') > 7 else 0
    
    # 5. Prefix/Suffix "-" in Domain (cite: 1.3)
    domain = urlparse(url).netloc
    features['Prefix_Suffix'] = 1 if '-' in domain else 0
    
    # 6. Subdomain Count (cite: 1.3)
    dot_count = domain.count('.')
    features['Sub_Domains'] = 1 if dot_count > 2 else 0
    
    return features

# --- MODULE 2: DATA PREPROCESSING & TRAINING (Section 3.4 C) ---
def train_phishing_model(dataset_path=None):
    # For demonstration, we'll create a small synthetic dataset if no file is provided
    # Your project assumes a publicly available dataset (e.g., from Kaggle/UCI) (cite: 217)
    if dataset_path is None:
        data = {
            'having_IP': [0, 1, 0, 1, 0, 1],
            'URL_Length': [0, 1, 0, 1, 0, 1],
            'Have_At': [0, 0, 1, 1, 0, 0],
            'Prefix_Suffix': [0, 1, 0, 1, 0, 1],
            'label': [0, 1, 0, 1, 0, 1]  # 0: Legitimate, 1: Phishing
        }
        df = pd.DataFrame(data)
    else:
        df = pd.read_csv(dataset_path)

    # Features and Target split
    X = df.drop('label', axis=1)
    y = df['label']

    # 80/20 Train-Test Split (cite: 182)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Implementing Random Forest Classifier (cite: 213, 225)
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)

    # Predictions
    y_pred = model.predict(X_test)

    # --- PERFORMANCE EVALUATION (cite: 136, 194, 214) ---
    print("--- Model Performance Metrics ---")
    print(f"Accuracy:  {accuracy_score(y_test, y_pred):.2f}")
    print(f"Precision: {precision_score(y_test, y_pred):.2f}")
    print(f"Recall:    {recall_score(y_test, y_pred):.2f}")
    print(f"F1-Score:  {f1_score(y_test, y_pred):.2f}")
    
    return model

# --- MODULE 3: REAL-TIME PREDICTION ---
def predict_url(url, model):
    features = extract_features(url)
    features_df = pd.DataFrame([features])
    prediction = model.predict(features_df)
    result = "PHISHING" if prediction[0] == 1 else "LEGITIMATE"
    print(f"\nURL: {url}\nResult: {result}")

# Run Execution
if __name__ == "__main__":
    # 1. Train the model
    trained_rf_model = train_phishing_model()
    
    # 2. Test with a sample URL
    test_url = "http://secure-login-bank.com-update.info/login"
    predict_url(test_url, trained_rf_model)
